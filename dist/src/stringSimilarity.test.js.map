{"version":3,"sources":["../../src/stringSimilarity.test.js"],"names":["describe","WILDCARD","originalString","quotedString","it","expect","toBe","argument","param","someArray","z","undefined","someProp","anotherProp","aProp","yetAnotherProp","a","prop1","expectedResult","toStrictEqual","value","toEqual","each","shouldSortObjectKeys","source","target"],"mappings":"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","file":"stringSimilarity.test.js","sourcesContent":["import stringSimilarity, {\n  recursiveKeySort,\n  replaceWildcards,\n  restoreWildcards,\n} from './stringSimilarity';\n\ndescribe('stringSimilarity', () => {\n  const WILDCARD = '{{*}}';\n  const originalString = '{\"a\": {{*}}, \"b\": {{*}}123, \"c\": 123{{*}}, '\n      + '\"d\": 123{{*}}456, \"e\": \"{{*}}\", \"f\": \"{{*}}abc\", \"g\": \"abc{{*}}\" '\n      + '\"h\": \"abc{{*}}123\", \"i\": {{*}}}';\n  const quotedString = '{\"a\": \"{{%}}\", \"b\": \"{{%}}123\", \"c\": \"123{{%}}\", '\n    + '\"d\": \"123{{%}}456\", \"e\": \"{{*}}\", \"f\": \"{{*}}abc\", \"g\": \"abc{{*}}\" '\n    + '\"h\": \"abc{{*}}123\", \"i\": \"{{%}}\"}';\n\n  describe('recursiveKeySort', () => {\n    it('should return the argument if it is falsy', () => {\n      expect(recursiveKeySort(null)).toBe(null);\n    });\n\n    it('should return the argument if it is not an object', () => {\n      const argument = 'not an object';\n      expect(recursiveKeySort(argument)).toBe(argument);\n    });\n\n    it('should return the argument with object keys sorted', () => {\n      const param = {\n        someArray: [\n          'something',\n          { z: undefined, someProp: 'someProp', anotherProp: 1 },\n        ],\n        aProp: {\n          someProp: { yetAnotherProp: null, anotherProp: true },\n          a: 'a',\n        },\n        prop1: 'prop1',\n      };\n\n      const expectedResult = {\n        aProp: {\n          a: 'a',\n          someProp: { anotherProp: true, yetAnotherProp: null },\n        },\n        prop1: 'prop1',\n        someArray: ['something', { anotherProp: 1, someProp: 'someProp', z: undefined }],\n      };\n\n      expect(recursiveKeySort(param)).toStrictEqual(expectedResult);\n    });\n  });\n\n  describe('replaceWildcards', () => {\n    it('returns the original value argument when no matches are found', () => {\n      const value = 'some string without wildcards';\n      expect(replaceWildcards(value)).toBe(value);\n    });\n\n    it('should find and replace all unquoted wildcards properly', () => {\n      expect(replaceWildcards(originalString, true)).toEqual(quotedString);\n    });\n  });\n\n  describe('restoreWildcards', () => {\n    it('returns the original value argument when no matches are found', () => {\n      const value = 'some string with a {{*}}';\n      expect(restoreWildcards(value)).toBe(value);\n    });\n\n    it('should find and replace all quoted wildcards properly', () => {\n      expect(restoreWildcards(quotedString)).toEqual(originalString);\n    });\n  });\n\n  describe.each([true, false])('when shouldSortObjectKeys is %s', (shouldSortObjectKeys) => {\n    it('should match a target with a valid pattern', () => {\n      expect(stringSimilarity(`before${WILDCARD}after`, 'beforesomethingafter', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match a target with a valid pattern at the beginning', () => {\n      expect(stringSimilarity(`${WILDCARD}after`, 'somethingafter', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match a target with a valid pattern at the end', () => {\n      expect(stringSimilarity(`before${WILDCARD}`, 'beforesomething', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match a target without populated pattern', () => {\n      expect(stringSimilarity(`before${WILDCARD}after`, 'beforeafter', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match a target against a source without a wildcard', () => {\n      expect(stringSimilarity('string1', 'string1', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should not match a target against a source without a wildcard', () => {\n      expect(stringSimilarity('string1', 'string2', shouldSortObjectKeys)).toBe(false);\n    });\n\n    it('should not match a target with an empty source', () => {\n      expect(stringSimilarity('', 'something', shouldSortObjectKeys)).toBe(false);\n    });\n\n    it('should match an empty target against a wildcarded source', () => {\n      expect(stringSimilarity(`${WILDCARD}`, '', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match an null target against a wildcarded source', () => {\n      expect(stringSimilarity(`${WILDCARD}`, null, shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match if the source and target are both null', () => {\n      expect(stringSimilarity(null, null, shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should not match if the source and target are undefined and null', () => {\n      expect(stringSimilarity(null, undefined, shouldSortObjectKeys)).toBe(false);\n    });\n\n    it('should not match if the source and target are undefined and null', () => {\n      expect(stringSimilarity(null, 'something', shouldSortObjectKeys)).toBe(false);\n    });\n  });\n\n  describe('when source and target are valid JSON request bodies and shouldSortObjectKeys is true', () => {\n    describe('when wildcards are present in source', () => {\n      it('should not match when a wildcard is detected in a property key', () => {\n        const source = '{ \"some{{*}}\": \"someValue\", \"someOtherKey\": \"someOtherValue\" }';\n        const target = '{ \"someKey\": \"someValue\" }';\n\n        expect(stringSimilarity(source, target, true)).toBe(false);\n      });\n\n      it('should match when source and target are equivalent', () => {\n        const source = '{ \"someOtherKey\": \"some{{*}}Value\", \"someKey\": \"{{*}}\" }';\n        const target = '{ \"someKey\": \"someValue\", \"someOtherKey\": \"someOtherValue\" }';\n\n        expect(stringSimilarity(source, target, true)).toBe(true);\n      });\n\n      it('should not match when source and target are not equivalent', () => {\n        const source = '{ \"someOtherKey\": \"some{{*}}Value\", \"someKey\": \"{{*}}\" }';\n        const target = '{ \"someKey\": \"someValue\", \"someOtherKey\": \"somethingDifferent\" }';\n\n        expect(stringSimilarity(source, target, true)).toBe(false);\n      });\n    });\n\n    describe('when wildcards are not present in source', () => {\n      it('should match when source and target are equivalent', () => {\n        const source = '{ \"someOtherKey\": \"someOtherValue\", \"someKey\": \"someValue\" }';\n        const target = '{ \"someKey\": \"someValue\", \"someOtherKey\": \"someOtherValue\" }';\n\n        expect(stringSimilarity(source, target, true)).toBe(true);\n      });\n\n      it('should not match when source and target are equivalent', () => {\n        const source = '{ \"someOtherKey\": \"someOtherValue\", \"someKey\": \"someValue\" }';\n        const target = '{ \"someDifferentKey\": \"someValue\", \"someOtherKey\": \"someOtherValue\" }';\n\n        expect(stringSimilarity(source, target, true)).toBe(false);\n      });\n    });\n  });\n});\n"]}