{"version":3,"sources":["../../src/stringSimilarity.test.js"],"names":["describe","WILDCARD","it","expect","toBe","argument","param","someArray","z","undefined","someProp","anotherProp","aProp","yetAnotherProp","a","prop1","expectedResult","toStrictEqual","originalString","quotedString","each","makeParsable","value","toEqual","shouldSortObjectKeys","source","target"],"mappings":"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","file":"stringSimilarity.test.js","sourcesContent":["import stringSimilarity, {\n  recursiveKeySort,\n  replaceWildcards,\n} from './stringSimilarity';\n\ndescribe('stringSimilarity', () => {\n  const WILDCARD = '{{*}}';\n\n  describe('recursiveKeySort', () => {\n    it('should return the argument if it is falsy', () => {\n      expect(recursiveKeySort(null)).toBe(null);\n    });\n\n    it('should return the argument if it is not an object', () => {\n      const argument = 'not an object';\n      expect(recursiveKeySort(argument)).toBe(argument);\n    });\n\n    it('should return the argument with object keys sorted', () => {\n      const param = {\n        someArray: [\n          'something',\n          { z: undefined, someProp: 'someProp', anotherProp: 1 },\n        ],\n        aProp: {\n          someProp: { yetAnotherProp: null, anotherProp: true },\n          a: 'a',\n        },\n        prop1: 'prop1',\n      };\n\n      const expectedResult = {\n        aProp: {\n          a: 'a',\n          someProp: { anotherProp: true, yetAnotherProp: null },\n        },\n        prop1: 'prop1',\n        someArray: ['something', { anotherProp: 1, someProp: 'someProp', z: undefined }],\n      };\n\n      expect(recursiveKeySort(param)).toStrictEqual(expectedResult);\n    });\n  });\n\n  describe('replaceWildcards', () => {\n    const originalString = '{\"a\": {{*}}, \"b\": {{*}}123, \"c\": 123{{*}}, '\n      + '\"d\": 123{{*}}456, \"e\": \"{{*}}\", \"f\": \"{{*}}abc\", \"g\": \"abc{{*}}\" '\n      + '\"h\": \"abc{{*}}123\", \"i\": {{*}}}';\n    const quotedString = '{\"a\": \"{{%}}\", \"b\": \"{{%}}123\", \"c\": \"123{{%}}\", '\n      + '\"d\": \"123{{%}}456\", \"e\": \"{{*}}\", \"f\": \"{{*}}abc\", \"g\": \"abc{{*}}\" '\n      + '\"h\": \"abc{{*}}123\", \"i\": \"{{%}}\"}';\n\n    it.each([true, false])('returns the original value argument when no matches are found', (makeParsable) => {\n      const value = 'some string without wildcards';\n      expect(replaceWildcards(value, makeParsable)).toBe(value);\n    });\n\n    it('should find and replace all unquoted wildcards properly', () => {\n      expect(replaceWildcards(originalString, true)).toEqual(quotedString);\n    });\n\n    it('should find and replace all quoted wildcards properly', () => {\n      expect(replaceWildcards(quotedString)).toEqual(originalString);\n    });\n  });\n\n  describe.each([true, false])('when shouldSortObjectKeys is %s', (shouldSortObjectKeys) => {\n    it('should match a target with a valid pattern', () => {\n      expect(stringSimilarity(`before${WILDCARD}after`, 'beforesomethingafter', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match a target with a valid pattern at the beginning', () => {\n      expect(stringSimilarity(`${WILDCARD}after`, 'somethingafter', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match a target with a valid pattern at the end', () => {\n      expect(stringSimilarity(`before${WILDCARD}`, 'beforesomething', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match a target without populated pattern', () => {\n      expect(stringSimilarity(`before${WILDCARD}after`, 'beforeafter', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match a target against a source without a wildcard', () => {\n      expect(stringSimilarity('string1', 'string1', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should not match a target against a source without a wildcard', () => {\n      expect(stringSimilarity('string1', 'string2', shouldSortObjectKeys)).toBe(false);\n    });\n\n    it('should not match a target with an empty source', () => {\n      expect(stringSimilarity('', 'something', shouldSortObjectKeys)).toBe(false);\n    });\n\n    it('should match an empty target against a wildcarded source', () => {\n      expect(stringSimilarity(`${WILDCARD}`, '', shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match an null target against a wildcarded source', () => {\n      expect(stringSimilarity(`${WILDCARD}`, null, shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should match if the source and target are both null', () => {\n      expect(stringSimilarity(null, null, shouldSortObjectKeys)).toBe(true);\n    });\n\n    it('should not match if the source and target are undefined and null', () => {\n      expect(stringSimilarity(null, undefined, shouldSortObjectKeys)).toBe(false);\n    });\n\n    it('should not match if the source and target are undefined and null', () => {\n      expect(stringSimilarity(null, 'something', shouldSortObjectKeys)).toBe(false);\n    });\n  });\n\n  describe('when source and target are valid JSON request bodies and shouldSortObjectKeys is true', () => {\n    describe('when wildcards are present in source', () => {\n      it('should not match when a wildcard is detected in a property key', () => {\n        const source = '{ \"some{{*}}\": \"someValue\", \"someOtherKey\": \"someOtherValue\" }';\n        const target = '{ \"someKey\": \"someValue\" }';\n\n        expect(stringSimilarity(source, target, true)).toBe(false);\n      });\n\n      it('should match when source and target are equivalent', () => {\n        const source = '{ \"someOtherKey\": \"some{{*}}Value\", \"someKey\": \"{{*}}\" }';\n        const target = '{ \"someKey\": \"someValue\", \"someOtherKey\": \"someOtherValue\" }';\n\n        expect(stringSimilarity(source, target, true)).toBe(true);\n      });\n\n      it('should not match when source and target are not equivalent', () => {\n        const source = '{ \"someOtherKey\": \"some{{*}}Value\", \"someKey\": \"{{*}}\" }';\n        const target = '{ \"someKey\": \"someValue\", \"someOtherKey\": \"somethingDifferent\" }';\n\n        expect(stringSimilarity(source, target, true)).toBe(false);\n      });\n    });\n\n    describe('when wildcards are not present in source', () => {\n      it('should match when source and target are equivalent', () => {\n        const source = '{ \"someOtherKey\": \"someOtherValue\", \"someKey\": \"someValue\" }';\n        const target = '{ \"someKey\": \"someValue\", \"someOtherKey\": \"someOtherValue\" }';\n\n        expect(stringSimilarity(source, target, true)).toBe(true);\n      });\n\n      it('should not match when source and target are equivalent', () => {\n        const source = '{ \"someOtherKey\": \"someOtherValue\", \"someKey\": \"someValue\" }';\n        const target = '{ \"someDifferentKey\": \"someValue\", \"someOtherKey\": \"someOtherValue\" }';\n\n        expect(stringSimilarity(source, target, true)).toBe(false);\n      });\n    });\n  });\n});\n"]}