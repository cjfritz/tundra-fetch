{"version":3,"sources":["../../src/stringSimilarity.js"],"names":["WILDCARD_MARKER_ESCAPED","WILDCARD_MARKER","UNQUOTED_WILDCARD_PLACEHOLDER","searchUnquotedWildcards","RegExp","searchUnquotedWildcardPlaceholders","getIsMatch","source","target","wildcardedSource","replace","isMatch","recursiveKeySort","data","sortedData","Object","keys","sort","forEach","key","Array","isArray","values","replaceWildcards","value","makeParsable","processedValue","regEx","resultArray","exec","matchedString","matchedStringIndex","lastIndex","length","isWildcardInQuotes","startsWith","endsWith","matchWithWildcardPlaceholder","matchWithPlaceholderAndQuotes","concat","processedPortion","slice","remainingPortion","matchWithRestoredWildcard","restoredMatch","substr","shouldSortObjectKeys","isMatching","processedSource","processedTarget","JSON","parse","includes","Error","stringify","e"],"mappings":"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","file":"stringSimilarity.js","sourcesContent":["import escapeRegExp from 'lodash.escaperegexp';\nimport matcher from 'matcher';\nimport { isObject } from './helpers';\n\nexport const WILDCARD_MARKER_ESCAPED = '{{\\\\*}}';\nexport const WILDCARD_MARKER = '{{*}}';\nexport const UNQUOTED_WILDCARD_PLACEHOLDER = '{{%}}';\nconst searchUnquotedWildcards = new RegExp(/(([^:\\s,]*)\\{\\{\\*\\}\\}([^,:\\s}\\]]*))(?=[^,:}\\]\\s]*)/g);\nconst searchUnquotedWildcardPlaceholders = new RegExp(/(([^:\\s,]*)\\{\\{%\\}\\}([^,\\s}\\]]*))(?=[^,}\\]\\s]*)/g);\n\nconst getIsMatch = (source, target) => {\n  const wildcardedSource = source\n    .replace(new RegExp(escapeRegExp('*'), 'g'), '\\\\*')\n    .replace(new RegExp(escapeRegExp(WILDCARD_MARKER_ESCAPED), 'g'), '*');\n\n  return matcher.isMatch(target, wildcardedSource);\n};\n\nexport const recursiveKeySort = (data) => {\n  if (data && isObject(data)) {\n    const sortedData = {};\n    Object.keys(data).sort().forEach((key) => {\n      sortedData[key] = recursiveKeySort(data[key]);\n    });\n    if (Array.isArray(data)) {\n      return Object.values(sortedData);\n    }\n    return sortedData;\n  }\n  return data;\n};\n\nexport const replaceWildcards = (value, makeParsable) => {\n  let processedValue = value;\n  const regEx = makeParsable ? searchUnquotedWildcards : searchUnquotedWildcardPlaceholders;\n  let resultArray = regEx.exec(processedValue);\n\n  while (resultArray !== null) {\n    const matchedString = resultArray[0];\n    const matchedStringIndex = regEx.lastIndex - matchedString.length;\n\n    if (makeParsable) {\n      const isWildcardInQuotes = matchedString.startsWith('\"')\n        && matchedString.endsWith('\"');\n\n      if (!isWildcardInQuotes) {\n        const matchWithWildcardPlaceholder = matchedString\n          .replace(WILDCARD_MARKER, UNQUOTED_WILDCARD_PLACEHOLDER);\n        const matchWithPlaceholderAndQuotes = '\"'.concat(matchWithWildcardPlaceholder.concat('\"'));\n        const processedPortion = processedValue.slice(0, matchedStringIndex);\n        let remainingPortion = processedValue.slice(matchedStringIndex);\n        remainingPortion = remainingPortion.replace(matchedString, `${matchWithPlaceholderAndQuotes}`);\n        processedValue = processedPortion + remainingPortion;\n      }\n    } else {\n      const matchWithRestoredWildcard = matchedString\n        .replace(UNQUOTED_WILDCARD_PLACEHOLDER, WILDCARD_MARKER);\n      const restoredMatch = matchWithRestoredWildcard.substr(1, matchWithRestoredWildcard.length - 2);\n      processedValue = processedValue.replace(matchedString, `${restoredMatch}`);\n    }\n    resultArray = regEx.exec(processedValue);\n  }\n  return processedValue;\n};\n\nexport default (source, target, shouldSortObjectKeys) => {\n  if (!source || (source || '') === (target || '')) {\n    return source === target;\n  }\n\n  const isMatching = getIsMatch(source, target);\n\n  if (isMatching) {\n    return true;\n  }\n\n  if (shouldSortObjectKeys && source && target) {\n    try {\n      let processedSource = `${source}`;\n      let processedTarget = `${target}`;\n\n      processedSource = replaceWildcards(processedSource, true);\n      processedSource = JSON.parse(processedSource, (key, value) => {\n        if (key.includes(WILDCARD_MARKER)) {\n          throw new Error();\n        }\n        return value;\n      });\n      processedSource = JSON.stringify(recursiveKeySort(processedSource));\n      processedSource = replaceWildcards(processedSource);\n\n      processedTarget = JSON.parse(processedTarget);\n      processedTarget = JSON.stringify(recursiveKeySort(processedTarget));\n\n      return getIsMatch(processedSource, processedTarget);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return false;\n};\n"]}