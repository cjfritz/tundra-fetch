{"version":3,"sources":["../../src/stringSimilarity.js"],"names":["WILDCARD_MARKER_ESCAPED","WILDCARD_MARKER","UNQUOTED_WILDCARD_PLACEHOLDER","searchUnquotedWildcards","RegExp","searchModifiedWildcards","getIsMatch","source","target","wildcardedSource","replace","isMatch","recursiveKeySort","data","sortedData","Object","keys","sort","forEach","key","Array","isArray","values","replaceWildcards","value","makeParsable","processedValue","regEx","resultArray","exec","matchedString","matchedStringIndex","lastIndex","length","modifiedMatch","isWildcardInString","startsWith","endsWith","concat","processedPortion","slice","remainingPortion","substr","shouldSortObjectKeys","isMatching","processedSource","processedTarget","JSON","parse","includes","Error","stringify","e"],"mappings":"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","file":"stringSimilarity.js","sourcesContent":["import escapeRegExp from 'lodash.escaperegexp';\nimport matcher from 'matcher';\nimport { isObject } from './helpers';\n\nexport const WILDCARD_MARKER_ESCAPED = '{{\\\\*}}';\nexport const WILDCARD_MARKER = '{{*}}';\nexport const UNQUOTED_WILDCARD_PLACEHOLDER = '{{%}}';\nconst searchUnquotedWildcards = new RegExp(/(([^:\\s,]*)\\{\\{\\*\\}\\}([^,:\\s}\\]]*))(?=[^,:}\\]\\s]*)/g);\nconst searchModifiedWildcards = new RegExp(/(([^:\\s,]*)\\{\\{%\\}\\}([^,\\s}\\]]*))(?=[^,}\\]\\s]*)/g);\n\nconst getIsMatch = (source, target) => {\n  const wildcardedSource = source\n    .replace(new RegExp(escapeRegExp('*'), 'g'), '\\\\*')\n    .replace(new RegExp(escapeRegExp(WILDCARD_MARKER_ESCAPED), 'g'), '*');\n\n  return matcher.isMatch(target, wildcardedSource);\n};\n\nexport const recursiveKeySort = (data) => {\n  if (data && isObject(data)) {\n    const sortedData = {};\n    Object.keys(data).sort().forEach((key) => {\n      sortedData[key] = recursiveKeySort(data[key]);\n    });\n    if (Array.isArray(data)) {\n      return Object.values(sortedData);\n    }\n    return sortedData;\n  }\n  return data;\n};\n\nexport const replaceWildcards = (value, makeParsable) => {\n  let processedValue = value;\n  const regEx = makeParsable ? searchUnquotedWildcards : searchModifiedWildcards;\n  let resultArray = regEx.exec(processedValue);\n\n  while (resultArray !== null) {\n    const matchedString = resultArray[0];\n    const matchedStringIndex = regEx.lastIndex - matchedString.length;\n    let modifiedMatch;\n\n    if (makeParsable) {\n      const isWildcardInString = matchedString.startsWith('\"')\n        && matchedString.endsWith('\"');\n\n      if (!isWildcardInString) {\n        modifiedMatch = matchedString\n          .replace(WILDCARD_MARKER, UNQUOTED_WILDCARD_PLACEHOLDER);\n        modifiedMatch = '\"'.concat(modifiedMatch.concat('\"'));\n        const processedPortion = processedValue.slice(0, matchedStringIndex);\n        let remainingPortion = processedValue.slice(matchedStringIndex);\n        remainingPortion = remainingPortion.replace(matchedString, `${modifiedMatch}`);\n        processedValue = processedPortion + remainingPortion;\n      }\n    } else {\n      modifiedMatch = matchedString\n        .replace(UNQUOTED_WILDCARD_PLACEHOLDER, WILDCARD_MARKER);\n      modifiedMatch = modifiedMatch.substr(1, modifiedMatch.length - 2);\n      processedValue = processedValue.replace(matchedString, `${modifiedMatch}`);\n    }\n    resultArray = regEx.exec(processedValue);\n  }\n  return processedValue;\n};\n\nexport default (source, target, shouldSortObjectKeys) => {\n  if (!source || (source || '') === (target || '')) {\n    return source === target;\n  }\n\n  const isMatching = getIsMatch(source, target);\n\n  if (isMatching) {\n    return true;\n  }\n\n  if (shouldSortObjectKeys && source && target) {\n    try {\n      let processedSource = `${source}`;\n      let processedTarget = `${target}`;\n\n      processedSource = replaceWildcards(processedSource, true);\n      processedSource = JSON.parse(processedSource, (key, value) => {\n        if (key.includes(WILDCARD_MARKER)) {\n          throw new Error();\n        }\n        return value;\n      });\n      processedSource = JSON.stringify(recursiveKeySort(processedSource));\n      processedSource = replaceWildcards(processedSource);\n\n      processedTarget = JSON.parse(processedTarget);\n      processedTarget = JSON.stringify(recursiveKeySort(processedTarget));\n\n      return getIsMatch(processedSource, processedTarget);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return false;\n};\n"]}